# База данни

Направете gem за in-memory база от данни на Ruby.

## Функционалности

- Цялата информация на базата от данни трябва да се съхранява локално в един файл, подобно на SQLite. Какъв да е самият формат, зависи от вашата имплементация - `json`, `csv` или нещо което вие сте си дефинирали като формат.
- Gem-а трябва да доставя достъп до базата посредством следния прост интерфейс или нещо сходно:

```
connection = RubyDB.connect('/path/to/db.json')
connection.execute('SELECT * FROM random_table')
```

- Базата трябва да разбира от подмножество на [SQL](https://en.wikipedia.org/wiki/SQL)

## SQL Data Definition

Вашата база от данни трябва да подържа следните операции за дефиниране на схемата:

- Създаване на таблици с множество колони притежаващи различни типове (поне `text`, `integer`, `float`).
- Ограничения относно колоните за `NULL` (дали колоната може или не може да има `NULL` като валидна стойност).
- Опционално, ограничения относно [foreign keys](http://www.w3schools.com/sql/sql_foreignkey.asp).
- Стойности по подразбиране за колоните.

Примерно създаване на две таблици:

```
CREATE TABLE city(
    id integer NOT NULL,
    name text NOT NULL
);

CREATE TABLE shop(
    id integer NOT NULL,
    name text NOT NULL,
    address text DEFAULT 'unknown',
    city_id integer REFERENCES city(id)
);
```

## SQL Data Manipulation

Трябва да се подържат следните операции за модифициране на данните:

- Добавяне на нови записи в съществуващите таблици.
- Премахване на записи.
- Промяна на съществуващ запис по просто условие.

Например:

```
INSERT INTO city (id, name) VALUES (1, 'Sofia');
UPDATE city SET name = 'Burgas' WHERE id = 1;
DELETE FROM city WHERE id = 1;
```

## SQL Queries

Заявките към нашата база трябва да подържат следните неща:

- Избиране само на определени колони от таблиците.
- Филтриране по условия посочени в `WHERE` клаузата на заявката (прости сравнения `=`, `>`, `<`, `>=`, `<=`, `IN (list of values)`)
- Ограничаване на броя върнати записи.
- Прескачане на определен брой записи.
- Сортиране на редовете по дадена колона.
- [Join](http://www.w3schools.com/sql/sql_join.asp). Достатъчно е да имплементирате един вид join.

Примерни заявки към базата:

```
SELECT * FROM city ORDER BY id OFFSET 3 LIMIT 1;
SELECT name, address FROM shop WHERE id = 5;
SELECT shop.name, shop.address, city.name FROM shop JOIN city ON city.id = shop.city_id WHERE shop.name IN ('Elixir and Ruby', 'Grafiti');
```

## Забележки

- Всички примери са вдъхновени от sql синтаксиса на [PostgreSQL](https://www.postgresql.org/docs/9.0/static/sql.html). Това е само за примерни цели. Синтаксисът на вашия SQL може да се различава, с цел по-лесна работа с него, но трябва да подържа посочените горе операции.
- Съсредоточете се върху функционалноста, не върху бързината на операциите. Бързината няма да е фактор за оценяването ви.
- Прегледайте следния [tutorial](http://www.w3schools.com/sql/sql_intro.asp) за още примери и вдъхновение.
- Въпреки, че се очаква комуникацията с библиотеката ви да минава през `SQL` - това не значи да създадете един гигантски метод, който парсва `sql`-а. Вътрешно библиотеката ви може да създава множество класове, които да си взаимодействат така, че да възпроизведат нужния резултат.
- Прочетете [тази тема от форума](http://fmi.ruby.bg/topics/419).
